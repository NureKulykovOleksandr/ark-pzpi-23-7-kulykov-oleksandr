Міністерство освіти та науки України
Харківський національний університет радіоелектроніки

Кафедра ПІ




ЗВІТ
з практичного заняття №1
з дисципліни «Аналіз та Рефакторинг Коду»
на тему «Правила оформлення програмного коду у мові Ruby»






Виконав:                                                                            Прийняв:
ст. гр. ПЗПІ-23-7                                                               ст. викл. каф. ПІ
Куликов Олександр Віталійович                                     Сокорчук Ігор Петрович








Харків 2025
1 ІСТОРІЯ ЗМІН

№	Дата	Версія звіту	Опис змін та виправлень
1	04.11.2025	1.0	Створено та повністю оформлено звіт

 
2 ЗАВДАННЯ

Студент повинен обрати мову програмування, дослідити основні рекомендації для написання якісного коду у цій мові, продемонструвати ці рекомендації на прикладах коду, обґрунтувати кожну рекомендацію і надати детальні пояснення. 
Студенту необхідно обрати мову програмування для аналізу. Після вибору мови програмування студенту потрібно ознайомитися з основними рекомендаціями для написання якісного та чистого коду у цій мові. Це можуть бути стильові рекомендації, правила найменування змінних, функцій та класів, структура коду, принципи рефакторингу, оптимізація продуктивності, обробка помилок, дотримання парадигм програмування, тестування та документування коду тощо.
Студент повинен підготувати один або кілька прикладів коду, які демонструють, як потрібно застосовувати наведені рекомендації. Приклад коду може бути загальним і об'єднувати декілька рекомендацій, або ж студент може підготувати кілька окремих прикладів для різних аспектів рекомендацій.
Студент повинен надати докладні пояснення щодо кожної рекомендації, підготувати слайди або текстову доповідь для презентації власного аналізу та представити свою доповідь викладачу.
 
3 ОПИС ВИКОНАНОЇ РОБОТИ

3.1 Вибір мови програмування та її особливості
Для аналізу обрано мову програмування Ruby. Це динамічна, інтерпретована, об'єктно-орієнтована мова, відома своїм фокусом на простоті та продуктивності розробника. Філософія Ruby ("Principle of Least Surprise" – Принцип найменшого здивування) робить читабельність та ясність коду центральними елементами екосистеми.

3.2 Важливість правильного оформлення коду
Дотримання єдиних правил оформлення коду є критичним для довгострокової підтримки проєкту. Це надає ключові переваги: покращує читабельність, що дозволяє новим членам команди швидше розуміти логіку, та напряму впливає на підтримуваність, спрощуючи дебаггінг і рефакторинг. Крім того, командна робота стає ефективнішою, бо єдині стандарти усувають суперечки про стиль. Як наслідок, логічний код містить менше прихованих багів.

3.3 Загальні правила: Іменування
Імена мають бути зрозумілими, описовими та передбачуваними, відповідаючи на питання "що це?" або "що це робить?". У Ruby прийняті чіткі конвенції, що допомагають розрізняти сутності (напр., змінна чи клас) лише за їхнім іменем. Це фундаментальна частина "Principle of Least Surprise", оскільки конвенція іменування несе семантичне навантаження.
Класи та Модулі іменуються у PascalCase (або CamelCase). Методи та змінні іменуються у snake_case (нижній регістр з підкресленням).




# Погано
class S # Незрозуміла назва класу
    def calc(a, i) # Незрозумілі назви методу та аргументів
        # ...
    end
end

# Добре
class Statistics
    def calculate_sum(items)
        # ...
    end
end

3.4 Загальні правила: Коментарі та структура
Коментарі та візуальна структура коду є ключовими для читабельності. У Ruby коментарі реалізації (символ #) мають пояснювати чому щось зроблено, а не що (код має бути самодокументованим). Документаційні коментарі (для інструменту YARD) описують API за допомогою тегів @param та @return. Структура коду, зокрема використання порожніх рядків, візуально групує логічні блоки коду, покращуючи сприйняття.

# Погано (зайвий коментар)
i = 0
# Додаємо 1 до i
i += 1

# Добре (пояснення "Чому?")
# Тимчасовий обхід бага в API v1.2,
# який не обробляє нульові значення
i = 1 unless i.present?

# Добре (структурування коду)
def process_data(data)
    # Блок 1: Збір даних
    raw_data = fetch_data(data)
    
    # Блок 2: Обробка
    processed_data = analyze(raw_data)
    
    # Блок 3: Збереження
    save_result(processed_data)
end




3.5 Оформлення функцій та методів
Методи (функції) є основними будівельними блоками програми. Їх оформлення напряму впливає на складність та підтримуваність системи. Ключовим є Принцип єдиної відповідальності (SRP), який стверджує, що функція має робити лише одну річ. Це призводить до коротких, чітко названих методів з малою кількістю аргументів. Короткість є важливою (в ідеалі до 15 рядків). Ім'я має чітко відповідати призначенню; наприклад, методи, що повертають true/false, закінчуються на ? (напр., admin?), а "небезпечні" методи, що змінюють об'єкт, закінчуються на !. Також важливо дотримуватись мінімуму аргументів: в ідеалі 0-2, а якщо більше – їх варто згрупувати в об'єкт або хеш

3.6 Форматування: Відступи та дужки
Послідовність форматування є критичною для командної роботи. У Ruby-спільноті склалися чіткі стандарти. Відступи використовуються для позначення рівня вкладеності; стандартом є 2 пробіли, табуляція не використовується. Блоки коду мають два стилі: фігурні дужки { ... } для коротких, однорядкових блоків та do ... end для багаторядкових. Для автоматизації цих правил та забезпечення їх дотримання використовується лінтер RuboCop, який є галузевим стандартом в екосистемі Ruby.
# Погано (4 пробіли, неправильні дужки)
items.each do |item| puts item end

# Добре (2 пробіли, правильні дужки)
items.each { |item| puts item }

users.map do |user|
  user.name.capitalize
end
 
3.7 Приклад рефакторингу "До та Після"
Розглянемо практичний приклад, що об'єднує декілька розглянутих правил. Початковий код ("Погано") порушує іменування (class S, def calc, змінна i), містить "магічні числа" (0.9, 100, 0.95) та порушує Принцип єдиної відповідальності (SRP), оскільки метод calc виконує і розрахунок знижки, і підсумовування. У версії "Добре" застосовано рефакторинг: імена стали змістовними (ShoppingCart), "магічні числа" винесені в константи, а логіка розрахунку ціни винесена в окремий приватний метод price_for (рефакторинг "Видобування методу").
# --- Погано ---
class S
  def calc(items)
    total = 0
    items.each do |i|
      if i.type == 1
        price = i.price * 0.9 # Магічне число
        total += price > 100 ? price : price * 0.95
      else
        total += i.price
      end
    end
    total
  end
end

# --- Добре ---
class ShoppingCart
  # Магічні числа винесені в константи
  STANDARD_DISCOUNT_RATE = 0.9
  DISCOUNT_THRESHOLD = 100
  EXTRA_DISCOUNT_RATE = 0.95

  def calculate_total(items)
    items.sum { |item| price_for(item) }
  end

  private

  # Логіка винесена в окремий метод (SRP)
  def price_for(item)
    case item.type
    when 1
      price = item.price * STANDARD_DISCOUNT_RATE
      price > DISCOUNT_THRESHOLD ? price : price * EXTRA_DISCOUNT_RATE
    else
      item.price
    end
  end
end
 
3.8 Оформлення файлів та структури проєкту
Правильна організація файлів є важливою для навігації у проєкті. Для іменування файлів у Ruby використовує snake_case і назва має відповідати назві класу чи модуля, який у ньому визначено (напр., клас UserReport має знаходитись у файлі user_report.rb). Окрім назв, важливою є і структура директорій, яка має бути логічною. При використанні фреймворків, як-от Ruby on Rails, слід суворо дотримуватись їхніх конвенцій (напр., app/models, app/controllers), що значно спрощує пошук коду.
# Приклад структури Ruby on Rails
project/
  app/
    models/
      user.rb
      product.rb
    controllers/
      users_controller.rb
    views/
      users/
        index.html.erb
    services/
      payment_service.rb
  lib/
  config/
  db/
 

ВИСНОВКИ

У результаті виконання практичного заняття було проведено дослідження основних принципів та рекомендацій з написання коду мовою програмування Ruby.
Було розглянуто ключові аспекти, що формують якісний код, зокрема: конвенції іменування, правила оформлення коментарів та структури коду, важливість Принципу єдиної відповідальності для методів, а також стандарти форматування. Також було продемонстровано практичний приклад рефакторингу коду для ілюстрації цих правил.
Виконана робота показала, що послідовне дотримання стандартів оформлення, часто автоматизоване за допомогою інструментів як RuboCop, є фундаментальною частиною професійної розробки. Це підтверджує, що чистий код напряму впливає на швидкість, вартість та успішність підтримки програмного продукту в екосистемі Ruby.
 
ВИКОРИСТАНІ ДЖЕРЕЛА

1.	Martin R. C. Clean Code: A Handbook of Agile Software Craftsmanship. Prentice Hall, 2008. 464 с.
2.	Fowler M. Refactoring: Improving the Design of Existing Code (2nd Edition). Addison-Wesley Professional, 2018. 448 с.
3.	Bozhidar Batsov et al. The Ruby Style Guide. URL: https://github.com/rubocop/ruby-style-guide (дата звернення: 04.11.2025).
4.	Metz S. Practical Object-Oriented Design in Ruby: An Agile Primer. Addison-Wesley, 2012. 272 c.
5.	RuboCop: The Ruby Linter/Formatter. URL: 
https://rubocop.org/ (дата звернення: 04.11.2025).
 
ДОДАТОК А

Відеозапис

Відеозапис доповіді: https://www.youtube.com/watch?v=LrVfqm2GpDg

Хронологічний опис відеозапису:
00:00 - Вступ та привітання. 
00:33 - Значення чистого коду: навіщо це потрібно? 
01:44 - Правила іменування змінних, методів та класів у Ruby. 
02:59 - Робота з коментарями та логічне структурування коду.
04:09 - Оформлення функцій: принцип SRP та кількість аргументів. 
05:36 - Правила форматування: відступи, дужки та автоматизація. 
06:46 - Практичний приклад: Рефакторинг коду "До та Після". 
08:46 - Оформлення файлів та структура проєкту в Ruby. 
09:37 - Висновки та ключові принципи якісного коду. 
10:35 - Список використаних джерел.
 
Додаток Б

Слайди презентації

 
Рисунок Б.1 – Титульний слайд

 
Рисунок Б.2 –Вступ: Навіщо потрібен чистий код?
 
Рисунок Б.3 –Загальні правила: Іменування

 
Рисунок Б.4 –Загальні правила: Коментарі та структура

 
Рисунок Б.5 –Оформлення функцій та методів

 
Рисунок Б.6 – Форматування: Відступи та дужки

 
Рисунок Б.7 – Приклад "До та Після" 

 
Рисунок Б.8 – Оформлення файлів та структури проєкту

 
Рисунок Б.9 – Висновки

 
Рисунок Б.10 – Використані джерела




