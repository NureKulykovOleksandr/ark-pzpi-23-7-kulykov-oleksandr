Міністерство освіти та науки України
Харківський національний університет радіоелектроніки

Кафедра ПІ






ЗВІТ
з практичного заняття №2
з дисципліни «Аналіз та Рефакторинг Коду»
на тему «Методи рефакторингу коду програмного забезпечення»






Виконав:								Прийняв:
ст. гр. ПЗПІ-23-7							ст. викл. кат. ПІ
Куликов Олександр Віталійович				Сокорчук Ігор Петрович 






Харків 2025
1 ІСТОРІЯ ЗМІН

№	Дата	Версія звіту	Опис змін та виправлень
1	23.12.25	1.0	Створено та повністю оформлено звіт

 
2 ЗАВДАННЯ

Студент повинен обрати три методи рефакторингу коду із книги Мартіна Фаулера «Refactoring. Improving the Design of Existing Code».
Навести приклади свого особистого коду (з курсових, лабораторних або інших проєктів), який потребує покращення, та продемонструвати застосування обраних методів.
Кожен метод рефакторингу повинен супроводжуватись:
1)	Описом проблеми, яку вирішує даний метод.
2)	Кодом до і після застосування методу рефакторингу.
3)	Поясненням переваг використаного методу.
Студент має вибрати три методи рефакторингу з книги Мартіна Фаулера, які підходять для його проєктів, та погодити їх із викладачем. Робота передбачає демонстрацію прикладів коду та підготовку доповіді з поясненням кожного методу.
Кожен метод повинен супроводжуватися конкретним прикладом з коду студента. Це можуть бути фрагменти з курсових, лабораторних або інших проєктів, написаних на будь-якій мові програмування. 
Студент повинен надати докладні пояснення щодо кожного методу, підготувати слайди або текстову доповідь для презентації власного аналізу та представити свою доповідь викладачу.
 
3 ОПИС ВИКОНАНОЇ РОБОТИ

3.1 Вибір методів рефакторингу
Було обрано три методи рефакторінгу коду:
1)	Consolidate Conditional Expression;
2)	Remove Middle Man;
3)	Separate Domain from Presentation.

3.2 Важливість рефакторингу
Рефакторинг є критично важливим етапом розробки, оскільки він дозволяє зменшити технічний борг без зміни зовнішньої поведінки системи. Чистий код легше читати, простіше тестувати та дешевше підтримувати. Регулярне застосування методів рефакторингу дозволяє уникнути деградації архітектури програмного забезпечення та спрощує інтеграцію нових розробників у проєкт.

3.3 Consolidate Conditional Expression
3.3.1 Опис методу
Цей метод застосовується у випадках, коли в коді присутня послідовність умовних перевірок (операторів if), які перевіряють різні умови, але призводять до виконання однієї й тієї ж дії. Така структура призводить до дублювання коду та ускладнює його сприйняття. Суть рефакторингу полягає в об'єднанні цих умов в один вираз за допомогою логічних операторів (AND, OR) або використанні допоміжних методів перевірки.

3.3.2 Приклад проблемного коду
У файлі AddPropertyPage.jsx реалізовано логіку обробки адреси, отриманої від API картографічного сервісу. Було виявлено фрагмент коду, де три окремі блоки if перевіряли тип компонента адреси (locality, administrative_area_level_1 тощо). У кожному з цих блоків виконувалася ідентична операція присвоєння значення змінній city. Це є порушенням принципу DRY (Don't Repeat Yourself).

                place.address_components.forEach(component => {
                if (component.types.includes('country')) {
                    country = component.long_name;
                }

                // ПРОБЛЕМА: Дублювання перевірок та присвоєння
                if (component.types.includes('locality') && !city) {
                    city = component.long_name;
                } 
                else if (component.types.includes('administrative_area_level_2') && !city) {
                    city = component.long_name;
                } 
                else if (component.types.includes('administrative_area_level_1') && !city) {
                    city = component.long_name;
                }
            });

3.3.3 Вирішення проблеми
Для оптимізації коду було створено масив допустимих типів адрес. Замість трьох розрізнених перевірок використано метод масиву .includes(). Це дозволило звести всю логіку перевірки до одного рядка коду всередині єдиного блоку if. Код став більш декларативним, а додавання нових типів локацій у майбутньому потребуватиме лише розширення масиву, а не написання нових умов.
place.address_components.forEach(component => {
                if (component.types.includes('country')) {
                    country = component.long_name;
                }

                // РІШЕННЯ: Об'єднання умов в одну структуру
                const isCityType = component.types.some(type => 
                    ['locality', 'administrative_area_level_2', 'administrative_area_level_1'].includes(type)
                );

                if (isCityType && !city) {
                    city = component.long_name;
                }
            });

3.4 Remove Middle Man
3.4.1 Опис методу 
Даний метод спрямований на усунення зайвих абстракцій. Він застосовується, коли клас або метод не виконує жодної корисної роботи (валідації, трансформації даних), а лише делегує виконання іншій функції чи об'єкту. Такі методи-посередники лише збільшують обсяг кодової бази та ускладнюють навігацію, не додаючи архітектурної цінності.

3.4.2 Приклад проблемного коду
У тому ж компоненті AddPropertyPage.jsx  було знайдено функцію addCancellationRule. Ця функція складалася з одного рядка і слугувала лише обгорткою для виклику сетера стану setCancellationRules. Вона не містила жодної бізнес-логіки. Виклик цієї функції в обробнику подій створював ілюзію складності там, де її не було.

// ПРОБЛЕМА: Метод-посередник. Просто делегує виклик без додаткової логіки.
    const addCancellationRule = () => {
    setCancellationRules([...cancellationRules, { daysBeforeCheckIn: 0, refundPercentage: 0 }]);
    };

<button
          type="button"
          onClick={addCancellationRule}
          className="mt-2 text-sm text-purple-600 hover:text-purple-800 font-medium flex items-center py-1"
                            >
         <PlusCircleIcon className="w-5 h-5 mr-1" /> Add rule
                            </button>

3.4.3 Вирішення проблеми
Було застосовано техніку Inline Method. Функцію-посередника addCancellationRule було повністю видалено, а логіку оновлення стану перенесено безпосередньо в атрибут onClick відповідної кнопки. Це спростило структуру компонента, зменшило кількість рядків коду та зробило потік даних більш прозорим.
                 <button
         type="button"
         onClick={() => setCancellationRules([
                                  ...cancellationRules, 
         { daysBeforeCheckIn: 0, refundPercentage: 0 }
                              ])}
         className="mt-2 text-sm text-purple-600 hover:text-purple-800 font-medium flex items-center py-1"
                            >
        <PlusCircleIcon className="w-5 h-5 mr-1" /> Add rule
                            </button>



3.5 Separate Domain from Presentation
3.5.1 Опис методу
Це фундаментальний архітектурний патерн, особливо актуальний для SPA-додатків на React. Суть методу полягає у фізичному розділенні коду, що відповідає за бізнес-логіку (Domain Layer), та коду, що відповідає за відображення інтерфейсу (Presentation Layer). Ігнорування цього принципу призводить до появи так званих "Fat Components", які важко підтримувати, неможливо тестувати ізольовано та складно перевикористовувати.

3.5.2 Приклад проблемного коду
омпонент сторінки бронювання BookingPage.jsx  виконував занадто багато різнорідних функцій. В ньому були змішані:
	Управління локальним станом форми (useState).
	Асинхронні запити до серверного API (handleBooking).
	Інтеграція зі стороннім платіжним сервісом Stripe.
	JSX-розмітка для відображення інтерфейсу. Така сильна зв'язність (High Coupling) робила компонент крихким до змін.

const BookingPage = () => {
  // Велика кількість станів (State)
  const [isBooking, setIsBooking] = useState(false);
  const [selectedSeats, setSelectedSeats] = useState([]);
  const [tripDetails, setTripDetails] = useState(null);

  // Складна бізнес-логіка прямо в компоненті
  const handleBooking = async () => {
    // ... валідація токенів ...
    // ... запит до API бронювання ...
    // ... створення сесії Stripe ...
    window.location.href = sessionRes.data.url;
  };

  // Логіка розрахунків перемішана з UI
  const totalPrice = tripDetails ? tripDetails.price * selectedSeats.length : 0;

  return (
    <div className="bg-[#CDEEF2]">
       {/* ... 200 рядків верстки ... */}
    </div>
  );
};

3.5.3 Вирішення проблеми
Для рефакторингу було використано патерн Custom Hooks:
	Всю бізнес-логіку, включаючи роботу з API та станом, було винесено в окремий файл - хук useBooking.js.
	Компонент BookingPage було перетворено на презентаційний компонент, який отримує готові дані та функції-обробники з хука. Це дозволило ізолювати складну логіку бронювання, зробивши її придатною для Unit-тестування незалежно від UI.

// Компонент став чистим
const BookingPage = () => {
  // Підключення логіки одним рядком
  const { selectedSeats, handleBooking, totalPrice, isLoading } = 
      useBooking(scheduleId, passengers);

  if (isLoading) return <Loader />;

  return (
    <div className="bg-[#CDEEF2]">
       {/* Тільки JSX верстка */}
       <button onClick={handleBooking}>Pay ${totalPrice}</button>
    </div> ); };


ВИСНОВКИ

У ході виконання практичного заняття було проведено глибокий аналіз кодової бази та виконано рефакторинг ключових модулів системи.
Результати роботи демонструють ефективність застосованих методів:
Спрощення логіки управління: Завдяки методу Consolidate Conditional Expression вдалося позбутися дублювання в алгоритмах парсингу даних, що зробило код більш стійким до змін у структурі вхідних даних API.
Усунення надлишковості: Метод Remove Middle Man дозволив очистити компоненти від "мертвого вантажу" у вигляді функцій-обгорток, зменшивши загальний обсяг коду та спростивши його навігацію.
Архітектурна оптимізація: Найвагомішим досягненням стало впровадження Separate Domain from Presentation. Виділення бізнес-логіки у кастомні хуки дозволило досягти слабкої зв'язності (Low Coupling) та високої згуртованості (High Cohesion), що є ознакою якісної архітектури ПЗ.
Загалом, проведений рефакторинг підвищив читабельність коду та створив надійний фундамент для подальшого масштабування функціоналу додатку.
 
ВИКОРИСТАНІ ДЖЕРЕЛА

1.	Robert C. Martin - Clean Code: A Handbook of Agile Software Craftsmanship. (дата звернення 23.12.25)
2.	Fowler M. Refactoring: Improving the Design of Existing Code. Addison-Wesley Professional, 2018. 348 с. (дата звернення 23.12.25)
3.	Гарнат А. С. та ін. Проєктний Практикум “Сервіс бронювання житла Apartica”: AddPropertyPage.jsx URL: https://github.com/alinaharnat/Apartica-app/blob/main/frontend/src/pages/AddPropertyPage.jsx (дата звернення 23.12.25)
4.	Гарнат А. С. та ін. Проєктний Практикум "Сервіс бронювання житла Apartica": BookingPage.jsx. URL: https://github.com/alinaharnat/Apartica-app/blob/main/frontend/src/pages/BookingPage.jsx (дата звернення 23.12.25)
 
ДОДАТОК А

Відеозапис

Відеозапис доповіді: https://www.youtube.com/watch?v=y7ulFx1wUfc

Хронологічний опис відеозапису:
00:00 - Вступ 
00:28 - Огляд обраних методів рефакторингу.
01:36 - Метод 1: Consolidate Conditional Expression 
02:34 - Приклад коду "До" та "Після": оптимізація перевірок адреси
04:31 - Метод 2: Remove Middle Man 
05:13 - Приклад коду: видалення функції-посередника
06:26 - Метод 3: Separate Domain from Presentation 
07:02 - Приклад проблеми: "Fat Component" у BookingPage
07:43 - Вирішення: винесення логіки у Custom Hook.
08:39 - Висновки 
09:54 - Перелік використаних джерел
 
ДОДАТОК Б

Слайди презентації

 
Рисунок Б.1 – Титульний слайд

 
Рисунок Б.2 – Вступ та цілі роботи
 
Рисунок Б.3 – Consolidate Conditional Expression

 
Рисунок Б.4 – Приклад ДО: Дублювання перевірок

 
Рисунок Б.5 – Приклад ПІСЛЯ: Об'єднання умов

 
Рисунок Б.6 – Remove Middle Man

 
Рисунок Б.7 – Приклад ДО: Зайва функція-обгортка

 
Рисунок Б.8 – Приклад ПІСЛЯ: Inline-логіка

 
Рисунок Б.9 – Separate Domain from Presentation

 
Рисунок Б.10 – Приклад ДО: Змішана логіка

 
Рисунок Б.11 – Приклад ПІСЛЯ: Виділення хука

 
Рисунок Б.12 – Висновки

 
Рисунок Б.13 – Перелік використаних джерел


